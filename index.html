<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Native Functions Documentation</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                background: #1a1a1a;
                color: #e0e0e0;
                height: 100vh;
                overflow: hidden;
            }

            .header {
                background: #0d0d0d;
                padding: 1rem 1.5rem;
                border-bottom: 1px solid #333;
            }

            .search-container {
                max-width: 600px;
                margin: 0 auto 1rem auto;
            }

            .filter-bar {
                display: flex;
                justify-content: center;
                gap: 2rem;
                align-items: center;
            }

            .filter-group {
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .filter-group label {
                color: #888;
                font-size: 0.9rem;
            }

            .filter-select {
                padding: 0.5rem 0.75rem;
                background: #2a2a2a;
                border: 1px solid #404040;
                border-radius: 4px;
                color: #e0e0e0;
                font-size: 0.9rem;
                cursor: pointer;
            }

            .filter-select:focus {
                outline: none;
                border-color: #5c9eff;
            }

            .search-bar {
                width: 100%;
                padding: 0.75rem 1rem;
                background: #2a2a2a;
                border: 1px solid #404040;
                border-radius: 6px;
                color: #e0e0e0;
                font-size: 0.95rem;
            }

            .search-bar:focus {
                outline: none;
                border-color: #5c9eff;
                background: #333;
            }

            .main-container {
                display: flex;
                height: calc(100vh - 125px);
            }

            .function-list {
                width: 350px;
                background: #0d0d0d;
                border-right: 1px solid #333;
                overflow-y: auto;
            }

            .function-item {
                padding: 0.875rem 1.25rem;
                border-bottom: 1px solid #262626;
                cursor: pointer;
                transition: background 0.15s;
            }

            .function-item:hover {
                background: #1f1f1f;
            }

            .function-item.active {
                background: #2a2a2a;
                border-left: 3px solid #5c9eff;
            }

            .function-name {
                font-weight: 600;
                color: #5c9eff;
                font-size: 0.95rem;
                margin-bottom: 0.25rem;
            }

            .function-category {
                font-size: 0.8rem;
                color: #888;
            }

            .function-type {
                color: #aaa;
                text-transform: capitalize;
            }

            .api-set-badge {
                display: inline-block;
                padding: 0.15rem 0.5rem;
                border-radius: 3px;
                font-size: 0.75rem;
                margin-left: 0.5rem;
                font-weight: 500;
            }

            .api-set-badge.client {
                background: #1e40af;
                color: #93c5fd;
            }

            .api-set-badge.server {
                background: #065f46;
                color: #6ee7b7;
            }

            .detail-panel {
                flex: 1;
                padding: 2rem;
                overflow-y: auto;
                background: #1a1a1a;
            }

            .detail-content h1 {
                color: #5c9eff;
                margin-bottom: 0.5rem;
                font-size: 2rem;
            }

            .detail-content .category-badge {
                display: inline-block;
                background: #2a2a2a;
                padding: 0.25rem 0.75rem;
                border-radius: 4px;
                font-size: 0.85rem;
                color: #888;
                margin-bottom: 1.5rem;
            }

            .detail-content h2 {
                color: #e0e0e0;
                margin-top: 2rem;
                margin-bottom: 1rem;
                font-size: 1.3rem;
                border-bottom: 1px solid #333;
                padding-bottom: 0.5rem;
            }

            .detail-content p {
                line-height: 1.6;
                margin-bottom: 1rem;
                color: #b0b0b0;
            }

            .code-block {
                background: #0d0d0d;
                border: 1px solid #333;
                border-radius: 6px;
                padding: 1rem;
                margin: 1rem 0;
                overflow-x: auto;
            }

            .code-block code {
                color: #7dd3fc;
                font-family: "Courier New", monospace;
                font-size: 0.9rem;
                white-space: pre-wrap;
            }

            .param-list {
                list-style: none;
                margin: 1rem 0;
            }

            .param-list li {
                padding: 0.5rem;
                margin: 0.5rem 0;
                background: #0d0d0d;
                border-left: 3px solid #5c9eff;
                border-radius: 3px;
            }

            .param-name {
                color: #7dd3fc;
                font-weight: 600;
            }

            .param-type {
                color: #fbbf24;
                font-style: italic;
            }

            .param-modifier {
                color: #f87171;
                font-size: 0.85em;
                margin-left: 0.5rem;
            }

            .no-selection {
                text-align: center;
                color: #666;
                padding-top: 3rem;
            }

            .loading {
                text-align: center;
                color: #888;
                padding: 2rem;
            }

            ::-webkit-scrollbar {
                width: 10px;
            }

            ::-webkit-scrollbar-track {
                background: #0d0d0d;
            }

            ::-webkit-scrollbar-thumb {
                background: #404040;
                border-radius: 5px;
            }

            ::-webkit-scrollbar-thumb:hover {
                background: #4a4a4a;
            }
        </style>
    </head>
    <body>
        <div class="header">
            <div class="search-container">
                <input type="text" class="search-bar" id="searchBar" placeholder="Search functions..." />
            </div>
            <div class="filter-bar">
                <div class="filter-group">
                    <label>Category:</label>
                    <select id="categoryFilter" class="filter-select">
                        <option value="all">All</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>API Set:</label>
                    <select id="apiSetFilter" class="filter-select">
                        <option value="all">All</option>
                        <option value="client">Client</option>
                        <option value="server">Server</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>Type:</label>
                    <select id="typeFilter" class="filter-select">
                        <option value="all">All</option>
                        <option value="native">Native</option>
                        <option value="constructor">Constructor</option>
                        <option value="engine">Engine</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>Language:</label>
                    <select id="languageFilter" class="filter-select">
                        <option value="lua">Lua</option>
                        <option value="js">JS</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="main-container">
            <div class="function-list" id="functionList">
                <div class="loading">Loading functions...</div>
            </div>
            <div class="detail-panel" id="detailPanel">
                <div class="no-selection">
                    <h2>Select a function to view details</h2>
                </div>
            </div>
        </div>

        <script>
            // LuaDoc Parser
            class LuaDocParser {
                parseLuaFile(content, filePath) {
                    const lines = content.split(/\r?\n/);
                    const functions = [];

                    let description = "";
                    let pendingParams = [];
                    let pendingReturn = { type: "void", description: "" };

                    // filePath is the relative path, e.g. "client/native/Foo.lua" or
                    // "client/native/Character/Movement.lua"
                    const pathParts = filePath.split("/");

                    // apiSet: client / server / unknown
                    let apiSet = "unknown";
                    if (pathParts[0] === "client" || pathParts[0] === "server") {
                        apiSet = pathParts[0];
                    }

                    // type: native / engine / constructor / general
                    const type = pathParts[1] || "general";

                    // category: folder under type if present, else file base name
                    const fileName = pathParts[pathParts.length - 1] || "";
                    const fileBase = fileName.replace(/\.lua$/i, "");

                    let category = "misc";
                    if (pathParts.length > 3) {
                        // e.g. client/native/Character/Movement.lua → "Character"
                        category = pathParts[pathParts.length - 2];
                    } else if (pathParts.length > 2) {
                        // e.g. client/native/Foo.lua → "Foo"
                        category = fileBase || "misc";
                    } else {
                        category = fileBase || "misc";
                    }

                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();

                        // Doc comments
                        if (line.startsWith("---")) {
                            const comment = line.substring(3).trim();

                            if (comment.startsWith("@class")) {
                                // Skip class declarations
                                continue;
                            } else if (comment.startsWith("@param")) {
                                // @param name type @[out|opt] description...
                                const paramMatch = comment.match(/@param\s+(\S+)\s+(\S+)(?:\s+@\[(out|opt)\])?\s*(.*)/);
                                if (paramMatch) {
                                    const [, name, typeName, modifier, desc] = paramMatch;
                                    pendingParams.push({
                                        name,
                                        type: typeName,
                                        modifier: modifier || null,
                                        description: (desc || "").trim(),
                                    });
                                }
                            } else if (comment.startsWith("@return")) {
                                // @return type description...
                                const returnMatch = comment.match(/@return\s+(\S+)(?:\s+(.*))?/);
                                if (returnMatch) {
                                    pendingReturn = {
                                        type: returnMatch[1],
                                        description: returnMatch[2] ? returnMatch[2].trim() : "",
                                    };
                                }
                            } else if (!comment.startsWith("@")) {
                                // Free-text description line
                                description += (description ? " " : "") + comment;
                            }

                            // Function declarations (global or local)
                        } else if (line.startsWith("function") || line.startsWith("local function")) {
                            const funcMatch = line.match(/(?:local\s+)?function\s+(?:(\w+)[\.:])?(\w+)\s*\((.*?)\)/);
                            if (funcMatch) {
                                const [, className, funcName, params] = funcMatch;

                                const func = {
                                    name: funcName,
                                    category: category,
                                    apiSet: apiSet,
                                    type: type,
                                    description: description,
                                    className: className || null,
                                    parameters: pendingParams.slice(), // shallow copy
                                    returns: pendingReturn,
                                    rawParams: params,
                                };

                                functions.push(func);
                            }

                            // Reset doc state after a function
                            description = "";
                            pendingParams = [];
                            pendingReturn = { type: "void", description: "" };

                            // Any other non-empty, non-comment line: clear stray doc state
                        } else if (line !== "") {
                            description = "";
                            pendingParams = [];
                            pendingReturn = { type: "void", description: "" };
                        }
                    }

                    return functions;
                }

                generateSyntax(func) {
                    const params = func.parameters
                        .map((p) => {
                            let paramStr = `${p.type} ${p.name}`;
                            if (p.modifier === "opt") paramStr += " [optional]";
                            if (p.modifier === "out") paramStr += " [out]";
                            return paramStr;
                        })
                        .join(", ");

                    // Handle both standalone functions and class methods
                    const fullName = func.className ? `${func.className}.${func.name}` : func.name;
                    return `${func.returns.type} ${fullName}(${params})`;
                }

                generateExample(func, lang = "lua") {
                    if (lang === "lua") {
                        const className = func.className || "";
                        const callPrefix = className ? `${className}.` : "";
                        const params = func.parameters
                            .map((p) => {
                                if (p.type === "string") return `"value"`;
                                if (p.type === "boolean" || p.type === "bool") return "false";
                                if (p.type === "number" || p.type === "integer" || p.type === "float") return "0";
                                return "nil";
                            })
                            .join(", ");

                        if (func.returns.type !== "void") {
                            return `local result = ${callPrefix}${func.name}(${params})`;
                        } else {
                            return `${callPrefix}${func.name}(${params})`;
                        }
                    } else {
                        // JS example (basic conversion)
                        const params = func.parameters
                            .map((p) => {
                                if (p.type === "string") return `"value"`;
                                if (p.type === "boolean" || p.type === "bool") return "false";
                                if (p.type === "number" || p.type === "integer" || p.type === "float") return "0";
                                return "null";
                            })
                            .join(", ");

                        if (func.returns.type !== "void") {
                            return `const result = ${func.name}(${params});`;
                        } else {
                            return `${func.name}(${params});`;
                        }
                    }
                }
            }

            // Main Application
            let allFunctions = [];
            let filteredFunctions = [];
            let selectedFunction = null;
            let currentApiSet = "all";
            let currentCategory = "all";
            let currentLanguage = "lua";
            let currentType = "all";
            const parser = new LuaDocParser();

            // GitHub Configuration
            const GITHUB_OWNER = "Joshua-Hypersonic"; // Change this
            const GITHUB_REPO = "helix-docs"; // Change this
            const GITHUB_BRANCH = "main"; // Change this
            const DOCS_PATH = "docs"; // Base path where client/server folders are

            async function fetchGitHubDirectory(path) {
                const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${path}?ref=${GITHUB_BRANCH}`;

                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        console.error(`Failed to fetch directory: ${path}`);
                        return [];
                    }
                    return await response.json();
                } catch (error) {
                    console.error(`Error fetching directory ${path}:`, error);
                    return [];
                }
            }

            async function fetchGitHubFile(path) {
                const url = `https://raw.githubusercontent.com/${GITHUB_OWNER}/${GITHUB_REPO}/${GITHUB_BRANCH}/${path}`;

                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        console.error(`Failed to fetch file: ${path}`);
                        return null;
                    }
                    return await response.text();
                } catch (error) {
                    console.error(`Error fetching file ${path}:`, error);
                    return null;
                }
            }

            async function recursivelyFindLuaFiles(path, relativePath = "") {
                const files = [];
                const contents = await fetchGitHubDirectory(path);

                for (const item of contents) {
                    const itemRelativePath = relativePath ? `${relativePath}/${item.name}` : item.name;

                    if (item.type === "file" && item.name.endsWith(".lua")) {
                        files.push({
                            path: item.path,
                            relativePath: itemRelativePath,
                            downloadUrl: item.download_url,
                        });
                    } else if (item.type === "dir") {
                        const subFiles = await recursivelyFindLuaFiles(item.path, itemRelativePath);
                        files.push(...subFiles);
                    }
                }

                return files;
            }

            async function loadFunctions() {
                const listEl = document.getElementById("functionList");
                listEl.innerHTML = '<div class="loading">Loading functions from GitHub...</div>';

                try {
                    // Find all .lua files in client and server directories
                    const clientFiles = await recursivelyFindLuaFiles(`${DOCS_PATH}/client`, "client");
                    const serverFiles = await recursivelyFindLuaFiles(`${DOCS_PATH}/server`, "server");
                    const allFiles = [...clientFiles, ...serverFiles];

                    if (allFiles.length === 0) {
                        listEl.innerHTML = '<div class="loading">No Lua files found in repository</div>';
                        return;
                    }

                    listEl.innerHTML = `<div class="loading">Loading ${allFiles.length} functions...</div>`;

                    const functionMap = new Map();

                    // Fetch and parse each file
                    for (const file of allFiles) {
                        const content = await fetchGitHubFile(file.path);
                        if (!content) continue;

                        const parsed = parser.parseLuaFile(content, file.relativePath);

                        for (const func of parsed) {
                            const key = func.className ? `${func.className}.${func.name}` : func.name;

                            if (functionMap.has(key)) {
                                // Merge apiSets if same function exists in both client/server
                                const existing = functionMap.get(key);
                                if (!Array.isArray(existing.apiSet)) {
                                    existing.apiSet = [existing.apiSet];
                                }
                                if (!existing.apiSet.includes(func.apiSet)) {
                                    existing.apiSet.push(func.apiSet);
                                }
                            } else {
                                functionMap.set(key, func);
                            }
                        }
                    }

                    allFunctions = Array.from(functionMap.values());
                    filteredFunctions = [...allFunctions];

                    populateCategoryFilter();
                    renderFunctionList();
                } catch (error) {
                    console.error("Error loading functions:", error);
                    listEl.innerHTML = '<div class="loading">Error loading functions. Check console for details.</div>';
                }
            }

            function populateCategoryFilter() {
                const categories = [...new Set(allFunctions.map((f) => f.category))].sort();
                const categoryFilter = document.getElementById("categoryFilter");

                // Clear existing options except "All"
                categoryFilter.innerHTML = '<option value="all">All</option>';

                categories.forEach((category) => {
                    const option = document.createElement("option");
                    option.value = category.toLowerCase();
                    option.textContent = category;
                    categoryFilter.appendChild(option);
                });
            }

            function renderFunctionList() {
                const listEl = document.getElementById("functionList");
                listEl.innerHTML = "";

                if (filteredFunctions.length === 0) {
                    listEl.innerHTML = '<div class="loading">No functions found</div>';
                    return;
                }

                filteredFunctions.forEach((func) => {
                    const item = document.createElement("div");
                    item.className = "function-item";
                    if (selectedFunction === func) {
                        item.classList.add("active");
                    }

                    const badges = Array.isArray(func.apiSet) ? func.apiSet.map((set) => `<span class="api-set-badge ${set}">${set}</span>`).join(" ") : `<span class="api-set-badge ${func.apiSet}">${func.apiSet}</span>`;

                    const typeLabel = func.type ? ` · <span class="function-type">${func.type}</span>` : "";

                    item.innerHTML = `
                        <div class="function-name">${func.name}${badges}</div>
                        <div class="function-category">${func.category}${typeLabel}</div>
                    `;

                    item.addEventListener("click", () => {
                        selectedFunction = func;
                        renderFunctionList();
                        renderDetail(func);
                    });

                    listEl.appendChild(item);
                });
            }

            function renderDetail(func) {
                const detailEl = document.getElementById("detailPanel");

                const paramsHTML =
                    func.parameters.length > 0
                        ? func.parameters
                              .map((p) => {
                                  let modifierBadge = "";
                                  if (p.modifier === "opt") modifierBadge = '<span class="param-modifier">[optional]</span>';
                                  if (p.modifier === "out") modifierBadge = '<span class="param-modifier">[output]</span>';

                                  return `<li><span class="param-name">${p.name}</span> <span class="param-type">(${p.type})</span>${modifierBadge}${p.description ? " - " + p.description : ""}</li>`;
                              })
                              .join("")
                        : "<li>No parameters</li>";

                const apiSetBadge = Array.isArray(func.apiSet) ? func.apiSet.map((set) => `<span class="api-set-badge ${set}">${set}</span>`).join(" ") : `<span class="api-set-badge ${func.apiSet}">${func.apiSet}</span>`;

                const syntax = parser.generateSyntax(func);
                const example = parser.generateExample(func, currentLanguage);

                detailEl.innerHTML = `
                    <div class="detail-content">
                        <h1>${func.name}</h1>
                        <span class="category-badge">${func.category}</span>
                        ${apiSetBadge}

                        <p>${func.description || "No description available."}</p>

                        <h2>Syntax</h2>
                        <div class="code-block"><code>${syntax}</code></div>

                        <h2>Parameters</h2>
                        <ul class="param-list">${paramsHTML}</ul>

                        <h2>Returns</h2>
                        <p><span class="param-type">${func.returns.type}</span>${func.returns.description ? " - " + func.returns.description : ""}</p>

                        <h2>Example (${currentLanguage.toUpperCase()})</h2>
                        <div class="code-block"><code>${example}</code></div>
                    </div>
                `;
            }

            document.getElementById("searchBar").addEventListener("input", (e) => {
                const query = e.target.value.toLowerCase();
                filterFunctions(query, currentCategory, currentApiSet, currentType);
            });

            document.getElementById("categoryFilter").addEventListener("change", (e) => {
                currentCategory = e.target.value;
                const query = document.getElementById("searchBar").value.toLowerCase();
                filterFunctions(query, currentCategory, currentApiSet, currentType);
            });

            document.getElementById("apiSetFilter").addEventListener("change", (e) => {
                currentApiSet = e.target.value;
                const query = document.getElementById("searchBar").value.toLowerCase();
                filterFunctions(query, currentCategory, currentApiSet, currentType);
            });

            document.getElementById("typeFilter").addEventListener("change", (e) => {
                currentType = e.target.value;
                const query = document.getElementById("searchBar").value.toLowerCase();
                filterFunctions(query, currentCategory, currentApiSet, currentType);
            });

            document.getElementById("languageFilter").addEventListener("change", (e) => {
                currentLanguage = e.target.value;
                if (selectedFunction) {
                    renderDetail(selectedFunction);
                }
            });

            function filterFunctions(query, category, apiSet, type) {
                filteredFunctions = allFunctions.filter((func) => {
                    const matchesSearch = func.name.toLowerCase().includes(query) || func.category.toLowerCase().includes(query) || (func.description && func.description.toLowerCase().includes(query));

                    const matchesCategory = category === "all" || func.category.toLowerCase() === category;
                    const matchesApiSet = apiSet === "all" || (Array.isArray(func.apiSet) ? func.apiSet.includes(apiSet) : func.apiSet === apiSet);
                    const matchesType = type === "all" || func.type === type;

                    return matchesSearch && matchesCategory && matchesApiSet && matchesType;
                });
                renderFunctionList();
            }

            // Initialize
            loadFunctions();
        </script>
    </body>
</html>
