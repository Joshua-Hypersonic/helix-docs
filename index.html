<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Native Functions Documentation</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                background: #1a1a1a;
                color: #e0e0e0;
                height: 100vh;
                display: flex;
                flex-direction: column;
            }

            .header {
                padding: 1rem 1.5rem;
                background: #111827;
                border-bottom: 1px solid #333;
                display: flex;
                flex-direction: column;
                gap: 0.75rem;
            }

            .search-container {
                display: flex;
                align-items: center;
                gap: 0.75rem;
            }

            .search-bar {
                flex: 1;
                padding: 0.5rem 0.75rem;
                border-radius: 4px;
                border: 1px solid #333;
                background: #0b1120;
                color: #e5e7eb;
                outline: none;
            }

            .search-bar::placeholder {
                color: #6b7280;
            }

            .filter-bar {
                display: flex;
                gap: 1rem;
                flex-wrap: wrap;
                align-items: center;
            }

            .filter-group {
                display: flex;
                align-items: center;
                gap: 0.5rem;
                font-size: 0.9rem;
                color: #9ca3af;
            }

            .filter-select {
                padding: 0.3rem 0.5rem;
                border-radius: 4px;
                border: 1px solid #374151;
                background: #020617;
                color: #e5e7eb;
                font-size: 0.9rem;
                outline: none;
            }

            .main-container {
                display: flex;
                height: calc(100vh - 125px);
            }

            .function-list {
                width: 350px;
                background: #0d0d0d;
                border-right: 1px solid #333;
                overflow-y: auto;
            }

            .function-item {
                padding: 0.875rem 1.25rem;
                border-bottom: 1px solid #1f2933;
                cursor: pointer;
                transition: background 0.15s ease, border-left 0.15s ease;
                display: flex;
                flex-direction: column;
                gap: 0.1rem;
            }

            .function-item:hover {
                background: #111827;
            }

            .function-item.active {
                background: #1f2937;
                border-left: 3px solid #3b82f6;
            }

            .function-name {
                font-size: 0.95rem;
                color: #e5e7eb;
            }

            .function-meta {
                font-size: 0.8rem;
                color: #9ca3af;
            }

            .detail-panel {
                flex: 1;
                padding: 2rem;
                overflow-y: auto;
                background: #1a1a1a;
            }

            .detail-content h1 {
                color: #5c9eff;
                margin-bottom: 0.5rem;
                font-size: 2rem;
            }

            .detail-content .category-badge {
                display: inline-block;
                background: #2a2a2a;
                padding: 0.25rem 0.75rem;
                border-radius: 4px;
                font-size: 0.85rem;
                color: #888;
                margin-bottom: 1.5rem;
            }

            .detail-content h2 {
                color: #e0e0e0;
                margin-top: 2rem;
                margin-bottom: 1rem;
                font-size: 1.3rem;
                border-bottom: 1px solid #333;
                padding-bottom: 0.3rem;
            }

            .detail-content p {
                line-height: 1.6;
                color: #d1d5db;
                margin-bottom: 0.75rem;
            }

            .param-list {
                list-style: none;
                padding-left: 0;
                margin-left: 0;
                margin-bottom: 1rem;
            }

            .param-list li {
                padding: 0.3rem 0;
                border-bottom: 1px dashed #333;
                font-size: 0.9rem;
            }

            .param-name {
                font-weight: 600;
                color: #f9fafb;
                margin-right: 0.4rem;
            }

            .param-type {
                color: #60a5fa;
                font-family: Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
                font-size: 0.85rem;
            }

            .param-modifier {
                font-size: 0.75rem;
                color: #fcd34d;
                margin-left: 0.25rem;
            }

            .api-set-badge {
                display: inline-block;
                padding: 0.15rem 0.5rem;
                font-size: 0.75rem;
                border-radius: 999px;
                margin-left: 0.5rem;
                background: #374151;
                color: #d1d5db;
            }

            .api-set-badge.client {
                background: #1e40af;
                color: #93c5fd;
            }

            .api-set-badge.server {
                background: #065f46;
                color: #6ee7b7;
            }

            .type-badge {
                display: inline-block;
                padding: 0.15rem 0.5rem;
                font-size: 0.75rem;
                border-radius: 999px;
                margin-left: 0.5rem;
                background: #374151;
                color: #d1d5db;
            }

            .type-badge.native {
                background: #7c2d12;
                color: #fed7aa;
            }

            .type-badge.constructor {
                background: #4a044e;
                color: #f9a8d4;
            }

            .type-badge.engine {
                background: #064e3b;
                color: #6ee7b7;
            }

            .loading {
                padding: 1rem;
                color: #9ca3af;
                text-align: center;
            }

            .no-selection {
                display: flex;
                align-items: center;
                justify-content: center;
                height: 100%;
                color: #9ca3af;
            }

            .no-selection h2 {
                font-weight: 400;
            }

            ::-webkit-scrollbar {
                width: 8px;
            }

            ::-webkit-scrollbar-track {
                background: #0d0d0d;
            }

            ::-webkit-scrollbar-thumb {
                background: #404040;
                border-radius: 5px;
            }

            ::-webkit-scrollbar-thumb:hover {
                background: #4a4a4a;
            }
        </style>
    </head>
    <body>
        <div class="header">
            <div class="search-container">
                <input type="text" class="search-bar" id="searchBar" placeholder="Search classes or functions..." />
            </div>
            <div class="filter-bar">
                <div class="filter-group">
                    <label>Category:</label>
                    <select id="categoryFilter" class="filter-select">
                        <option value="all">All</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>API Set:</label>
                    <select id="apiSetFilter" class="filter-select">
                        <option value="all">All</option>
                        <option value="client">Client</option>
                        <option value="server">Server</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>Type:</label>
                    <select id="typeFilter" class="filter-select">
                        <option value="all">All</option>
                        <option value="native">Native</option>
                        <option value="constructor">Constructor</option>
                        <option value="engine">Engine</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="main-container">
            <div class="function-list" id="classList">
                <div class="loading">Loading classes...</div>
            </div>
            <div class="detail-panel" id="detailPanel">
                <div class="no-selection">
                    <h2>Select a class to view its functions</h2>
                </div>
            </div>
        </div>

        <script>
            // LuaDoc Parser (unchanged from original)
            class LuaDocParser {
                parseLuaFile(content, filePath) {
                    const lines = content.split(/\r?\n/);
                    const functions = [];

                    let description = "";
                    let pendingParams = [];
                    let pendingReturn = { type: "void", description: "" };

                    // Track the current @class in this file (for grouping only)
                    let currentDocClass = null;

                    // filePath is the relative path, e.g. "client/constructor/Actor/WebUI.lua"
                    const pathParts = filePath.split("/");

                    // apiSet: client / server / unknown
                    let apiSet = "unknown";
                    if (pathParts.includes("client")) apiSet = "client";
                    if (pathParts.includes("server")) apiSet = "server";

                    // type: native / constructor / engine / general
                    let type = "general";
                    if (pathParts.includes("native")) type = "native";
                    if (pathParts.includes("constructor")) type = "constructor";
                    if (pathParts.includes("engine")) type = "engine";

                    // Infer folder-based category as a fallback; e.g. "Actor"
                    const fileName = pathParts[pathParts.length - 1];
                    const fileBase = fileName.replace(/\.lua$/i, "");

                    let folderCategory = "misc";
                    if (pathParts.length > 3) {
                        // e.g. client/constructor/Actor/WebUI.lua → "Actor"
                        folderCategory = pathParts[pathParts.length - 2];
                    } else if (pathParts.length > 2) {
                        // e.g. client/constructor/Actor.lua → "Actor"
                        folderCategory = fileBase || "misc";
                    } else {
                        folderCategory = fileBase || "misc";
                    }

                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();

                        // ---- DOC COMMENTS ---------------------------
                        if (line.startsWith("---")) {
                            const comment = line.substring(3).trim();

                            if (comment.startsWith("@class")) {
                                // Capture declared class name for grouping, e.g. "@class WebUI"
                                const classMatch = comment.match(/@class\s+(\w+)/);
                                if (classMatch) {
                                    currentDocClass = classMatch[1];
                                }
                                continue;
                            } else if (comment.startsWith("@param")) {
                                const paramMatch = comment.match(/@param\s+(\S+)\s+(\S+)(?:\s+@\[(out|opt)\])?\s*(.*)/);
                                if (paramMatch) {
                                    const [, name, typeName, modifier, desc] = paramMatch;
                                    pendingParams.push({
                                        name,
                                        type: typeName,
                                        modifier: modifier || null,
                                        description: (desc || "").trim(),
                                    });
                                }
                            } else if (comment.startsWith("@return")) {
                                const returnMatch = comment.match(/@return\s+(\S+)(?:\s+(.*))?/);
                                if (returnMatch) {
                                    pendingReturn = {
                                        type: returnMatch[1],
                                        description: returnMatch[2] ? returnMatch[2].trim() : "",
                                    };
                                }
                            } else if (!comment.startsWith("@")) {
                                // Free-text description line
                                description += (description ? " " : "") + comment;
                            }

                            // ---- FUNCTION SIGNATURE --------------------
                        } else if (line.startsWith("function")) {
                            // Reset className from signature; e.g. "WebUI:Show()" or "WebUI.Show()"
                            let classNameFromSig = null;
                            let functionName = null;
                            let params = "";

                            // function WebUI.Show(param1, param2)
                            let match = line.match(/^function\s+([A-Za-z_]\w*)\.([A-Za-z_]\w*)\s*\((.*)\)/);
                            if (match) {
                                classNameFromSig = match[1];
                                functionName = match[2];
                                params = match[3];
                            } else {
                                // function WebUI:Show(param1, param2)
                                match = line.match(/^function\s+([A-Za-z_]\w*):([A-Za-z_]\w*)\s*\((.*)\)/);
                                if (match) {
                                    classNameFromSig = match[1];
                                    functionName = match[2];
                                    params = match[3];
                                } else {
                                    // function Show(param1, param2)
                                    match = line.match(/^function\s+([A-Za-z_]\w*)\s*\((.*)\)/);
                                    if (match) {
                                        functionName = match[1];
                                        params = match[2];
                                    }
                                }
                            }

                            if (!functionName) {
                                // Not a recognized function pattern; clear doc state and continue
                                description = "";
                                pendingParams = [];
                                pendingReturn = { type: "void", description: "" };
                                continue;
                            }

                            const paramList = params
                                .split(",")
                                .map((p) => p.trim())
                                .filter((p) => p.length > 0);

                            // If we have fewer @param entries than parameters in the signature, pad them with generic entries
                            if (pendingParams.length < paramList.length) {
                                for (let idx = pendingParams.length; idx < paramList.length; idx++) {
                                    const paramName = paramList[idx];
                                    pendingParams.push({
                                        name: paramName,
                                        type: "any",
                                        modifier: null,
                                        description: "",
                                    });
                                }
                            }

                            // Determine category:
                            //  1) use currentDocClass if it was declared via @class
                            //  2) else fall back to folderCategory
                            const category = currentDocClass || folderCategory || "General";

                            const func = {
                                name: functionName,
                                category: category,
                                folderCategory: folderCategory,
                                apiSet: apiSet,
                                type: type,
                                description: description,
                                className: classNameFromSig || null,
                                parameters: pendingParams.slice(),
                                returns: pendingReturn,
                                rawParams: params,
                            };

                            functions.push(func);

                            // Reset doc state after a function
                            description = "";
                            pendingParams = [];
                            pendingReturn = { type: "void", description: "" };

                            // ---- ANY OTHER REAL CODE LINE --------------------------------------
                        } else if (line !== "") {
                            // Real code line: clear any stray doc state that wasn't attached
                            description = "";
                            pendingParams = [];
                            pendingReturn = { type: "void", description: "" };
                        }
                    }

                    return functions;
                }
            }

            // GitHub Configuration
            const GITHUB_OWNER = "Joshua-Hypersonic";
            const GITHUB_REPO = "helix-docs";
            const GITHUB_BRANCH = "main";
            const DOCS_PATH = "docs";

            // State
            let allFunctions = [];
            let filteredFunctions = [];
            let classMap = {};
            let selectedClassKey = null;
            let currentApiSet = "all";
            let currentCategory = "all";
            let currentType = "all";
            const parser = new LuaDocParser();

            async function fetchGitHubDirectory(path) {
                const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${path}?ref=${GITHUB_BRANCH}`;
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        console.error(`Failed to fetch directory: ${path}`);
                        return [];
                    }
                    return await response.json();
                } catch (error) {
                    console.error(`Error fetching directory ${path}:`, error);
                    return [];
                }
            }

            async function fetchGitHubFile(path) {
                const url = `https://raw.githubusercontent.com/${GITHUB_OWNER}/${GITHUB_REPO}/${GITHUB_BRANCH}/${path}`;
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        console.error(`Failed to fetch file: ${path}`);
                        return null;
                    }
                    return await response.text();
                } catch (error) {
                    console.error(`Error fetching file ${path}:`, error);
                    return null;
                }
            }

            async function recursivelyFindLuaFiles(path, relativePath = "") {
                const files = [];
                const contents = await fetchGitHubDirectory(path);

                for (const item of contents) {
                    const itemRelativePath = relativePath ? `${relativePath}/${item.name}` : item.name;
                    if (item.type === "file" && item.name.endsWith(".lua")) {
                        files.push({
                            path: item.path,
                            relativePath: itemRelativePath,
                        });
                    } else if (item.type === "dir") {
                        const subFiles = await recursivelyFindLuaFiles(item.path, itemRelativePath);
                        files.push(...subFiles);
                    }
                }

                return files;
            }

            function applyFiltersAndRender() {
                const searchTerm = document.getElementById("searchBar").value.toLowerCase();
                const categoryFilter = document.getElementById("categoryFilter").value;
                const apiSetFilter = document.getElementById("apiSetFilter").value;
                const typeFilter = document.getElementById("typeFilter").value;

                filteredFunctions = allFunctions.filter((func) => {
                    const haystack = (func.name + " " + (func.description || "") + " " + (func.className || "") + " " + (func.category || "") + " " + (func.folderCategory || "")).toLowerCase();

                    if (searchTerm && !haystack.includes(searchTerm)) return false;

                    if (categoryFilter !== "all") {
                        const cat = (func.category || func.folderCategory || "").toLowerCase();
                        if (cat !== categoryFilter) return false;
                    }

                    if (apiSetFilter !== "all") {
                        if (Array.isArray(func.apiSet)) {
                            if (!func.apiSet.includes(apiSetFilter)) return false;
                        } else if (func.apiSet !== apiSetFilter) {
                            return false;
                        }
                    }

                    if (typeFilter !== "all" && func.type !== typeFilter) return false;

                    return true;
                });

                // Build class map from filtered functions
                classMap = {};
                for (const func of filteredFunctions) {
                    const key = func.className || func.category || func.folderCategory || "Global";
                    if (!classMap[key]) {
                        classMap[key] = {
                            key,
                            name: key,
                            functions: [],
                        };
                    }
                    classMap[key].functions.push(func);
                }

                const classKeys = Object.keys(classMap).sort((a, b) => a.localeCompare(b));

                if (!selectedClassKey || !classMap[selectedClassKey]) {
                    selectedClassKey = classKeys[0] || null;
                }

                renderClassList(classKeys);
                renderClassDetail(selectedClassKey);
            }

            function renderClassList(classKeys) {
                const listContainer = document.getElementById("classList");
                listContainer.innerHTML = "";

                if (!classKeys.length) {
                    listContainer.innerHTML = "<div class='loading'>No classes found</div>";
                    const detailEl = document.getElementById("detailPanel");
                    detailEl.innerHTML = "<div class='no-selection'><h2>No classes match the current filters</h2></div>";
                    return;
                }

                for (const key of classKeys) {
                    const group = classMap[key];
                    const item = document.createElement("div");
                    item.className = "function-item" + (key === selectedClassKey ? " active" : "");
                    item.textContent = `${group.name} (${group.functions.length})`;

                    item.addEventListener("click", () => {
                        selectedClassKey = key;
                        renderClassList(classKeys);
                        renderClassDetail(key);
                    });

                    listContainer.appendChild(item);
                }
            }

            function renderClassDetail(classKey) {
                const detailEl = document.getElementById("detailPanel");
                detailEl.innerHTML = "";

                const group = classMap[classKey];
                if (!group) {
                    detailEl.innerHTML = "<div class='no-selection'><h2>Select a class to view its functions</h2></div>";
                    return;
                }

                const functions = group.functions.slice().sort((a, b) => a.name.localeCompare(b.name));

                let html = "<div class='detail-content'>";
                html += `<h1>${group.name}</h1>`;
                html += `<span class="category-badge">Functions: ${functions.length}</span>`;

                functions.forEach((func) => {
                    const apiSetBadge = (() => {
                        if (Array.isArray(func.apiSet)) {
                            const text = func.apiSet.join(" / ");
                            return `<span class="api-set-badge">${text}</span>`;
                        } else if (func.apiSet) {
                            return `<span class="api-set-badge ${func.apiSet}">${func.apiSet}</span>`;
                        } else {
                            return `<span class="api-set-badge unknown">unknown</span>`;
                        }
                    })();

                    const paramsHTML =
                        func.parameters && func.parameters.length > 0
                            ? func.parameters
                                  .map((p) => {
                                      let modifierBadge = "";
                                      if (p.modifier === "opt") modifierBadge = '<span class="param-modifier">[optional]</span>';
                                      if (p.modifier === "out") modifierBadge = '<span class="param-modifier">[output]</span>';

                                      return `<li><span class="param-name">${p.name}</span> <span class="param-type">${p.type}</span> ${modifierBadge}${p.description ? " - " + p.description : ""}</li>`;
                                  })
                                  .join("")
                            : "<li>No parameters</li>";

                    const returns = func.returns || { type: "void", description: "" };
                    const returnsHTML = `<p><span class="param-type">${returns.type}</span>${returns.description ? " - " + returns.description : ""}</p>`;

                    html += `
                        <h2>${func.name}</h2>
                        ${apiSetBadge}
                        <p>${func.description || "No description available."}</p>
                        <h2>Parameters</h2>
                        <ul class="param-list">${paramsHTML}</ul>
                        <h2>Returns</h2>
                        ${returnsHTML}
                    `;
                });

                html += "</div>";
                detailEl.innerHTML = html;
            }

            function populateCategoryFilter() {
                const categories = [...new Set(allFunctions.map((f) => f.category).filter(Boolean))].sort();
                const categoryFilter = document.getElementById("categoryFilter");

                categoryFilter.innerHTML = '<option value="all">All</option>';

                categories.forEach((category) => {
                    const option = document.createElement("option");
                    option.value = category.toLowerCase();
                    option.textContent = category;
                    categoryFilter.appendChild(option);
                });
            }

            async function loadFunctions() {
                const listEl = document.getElementById("classList");
                listEl.innerHTML = '<div class="loading">Loading classes from GitHub...</div>';

                try {
                    const clientFiles = await recursivelyFindLuaFiles(`${DOCS_PATH}/client`, "client");
                    const serverFiles = await recursivelyFindLuaFiles(`${DOCS_PATH}/server`, "server");
                    const allFiles = [...clientFiles, ...serverFiles];

                    const functionMap = new Map();

                    for (const file of allFiles) {
                        const content = await fetchGitHubFile(file.path);
                        if (!content) continue;

                        const parsed = parser.parseLuaFile(content, file.relativePath);

                        for (const func of parsed) {
                            const key = func.className ? `${func.className}.${func.name}` : func.name;

                            if (functionMap.has(key)) {
                                const existing = functionMap.get(key);
                                if (!Array.isArray(existing.apiSet)) {
                                    existing.apiSet = [existing.apiSet];
                                }
                                if (!existing.apiSet.includes(func.apiSet)) {
                                    existing.apiSet.push(func.apiSet);
                                }
                            } else {
                                functionMap.set(key, func);
                            }
                        }
                    }

                    allFunctions = Array.from(functionMap.values());
                    filteredFunctions = [...allFunctions];

                    populateCategoryFilter();
                    applyFiltersAndRender();
                } catch (error) {
                    console.error("Error loading functions:", error);
                    listEl.innerHTML = '<div class="loading">Error loading classes. Check console for details.</div>';
                }
            }

            document.getElementById("searchBar").addEventListener("input", () => {
                applyFiltersAndRender();
            });

            document.getElementById("categoryFilter").addEventListener("change", (e) => {
                currentCategory = e.target.value;
                applyFiltersAndRender();
            });

            document.getElementById("apiSetFilter").addEventListener("change", (e) => {
                currentApiSet = e.target.value;
                applyFiltersAndRender();
            });

            document.getElementById("typeFilter").addEventListener("change", (e) => {
                currentType = e.target.value;
                applyFiltersAndRender();
            });

            // Initialize
            loadFunctions();
        </script>
    </body>
</html>
